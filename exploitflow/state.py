# Copyright 2022 VÃ­ctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import exploitflow as ef
import pprint
import copy

TARGET_PORTS_BASIC = list(range(21, 444))
TARGET_PORTS_OSX = [5000, 6000, 6001, 7000]
TARGET_PORTS_ALL = TARGET_PORTS_BASIC + TARGET_PORTS_OSX


class State(object):
    """Parent State class"""

    pass


# //////////////
# State_v0
# //////////////
class State_v0(State):
    """Basic data model.

    A state class for the basic operations. Helps
    monitor the system being tested.

    Parameters
    ----------
    sequence
        Basic type that's able to fit into a list. Typically int, bool, etc.

    Returns
    -------
    State_v0
        The state.
    """

    def __init__(self, *args):
        if args:
            if isinstance(args[0], int):
                self._sequence = [args[0]]
            elif isinstance(args[0], list):
                self._sequence = args[0]
        else:
            self._sequence = []

    def __str__(self):
        return str(self._sequence)

    def __add__(self, newstate):
        """Merge to stage objects"""
        return State_v0(self._sequence + newstate._sequence)


# //////////////
# State_v1
# //////////////
class ExploitState_v1(object):
    def __init__(self, type_exploit: object, launched: bool = False):
        self.type = type_exploit
        self.launched = launched


class PortState_v1(object):
    def __init__(
        self,
        port: int,
        open: bool = False,
        name: str = None,
        version: str = None,
        cpe: str = None,
    ):
        self.port = port
        self.open = open
        self.name = name
        self.version = version
        self.cpe = cpe


class State_v1(State):
    def __init__(self, *args):
        self.exploits = []
        self.ports = []

        # initialize all exploits as unlaunched (False)
        for c in ef.exploits_all:
            self.exploits.append(ExploitState_v1(c, False))
            # print(c.__name__)  # debug

        # initialize all ports to closed (False)
        for port in TARGET_PORTS_ALL:
            self.ports.append(PortState_v1(port))

    def __str__(self):
        """Returns dict with launched exploits and open ports"""
        d_return = {"exploits": [], "ports": []}
        for expl in self.exploits:
            if expl.launched:
                d_return["exploits"].append(str(expl.type.__name__))

        for port in self.ports:
            if port.open:
                d_return["ports"].append(
                    "port: " + str(port.port) + ", name: " + str(port.name) + ", version: " + str(port.version)
                )
        return str(pprint.pformat(d_return))

    def __repr__(self) -> str:
        return self.__str__()

    def __add__(self, newstate):
        """Merge two state objects"""
        return newstate

    def to_v2(self, target):
        """Merge two state objects"""
        


# //////////////
# State_v2
#  dictionary of State_v2 wherein each key corresponds
#  with the IP address of the target
# //////////////
class State_v2(State):
    def __init__(self, *args):
        self.states = {}

    def add(self, ip: str, state: State_v1) -> None:
        self.states[ip] = state

    def add_new(self, ip: str) -> None:
        state = State_v1()
        self.states[ip] = state

    def merge(self, newstate, target="127.0.0.1") -> None:
        """
        Merges the current object with a new State

        Supports both State_v1 and State_v2.
        """
        if type(newstate) == State_v1:
            self.states[target] = newstate  # whether it exists or not            
        elif type(newstate) == State_v2:
            aux_state = self + newstate  # NOTE: overwrites self, with newstate
            self.states = aux_state.states
        else:
            raise TypeError("Unknown state type")

    def __add__(self, newstate):
        """
        Merge two state objects

            NOTE: Overwrites self with newstate
        """
        aux_state = copy.deepcopy(self)

        for ip in newstate.states.keys():
            aux_state.states[ip] = newstate.states[ip]
        return newstate

    def __str__(self):
        """Returns dict with launched exploits and open ports"""
        return pprint.pformat(self.states)

    def __getitem__(self, key):
        return self.states[key]
    
    def __setitem__(self, key, value):
        self.states[key] = value

    def __repr__(self) -> str:
        return self.__str__()


def to_v2(state: State, target: str) -> State_v2:
    """
    Returns a new State_v2 of state
    """    
    # ensure aux_state is State_v2
    if type(state) == State_v1:
        aux_state = State_v2()
        aux_state.add(target, state)
    else:
        aux_state = copy.deepcopy(state)
    
    return aux_state


# //////////////
# Aliases
# //////////////

# State_default = State_v0
# State_default = State_v1
State_default = State_v2
