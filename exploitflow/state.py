# Copyright 2022 VÃ­ctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import exploitflow as ef
import pprint
import copy
import numpy as np
from sklearn.preprocessing import OneHotEncoder

# TARGET_PORTS_BASIC = list(range(21, 445))
TARGET_PORTS_BASIC = list(range(21, 30))
TARGET_PORTS_COMPLETE = list(range(1, 10000))
TARGET_PORTS_OSX = [5000, 6000, 6001, 7000]
TARGET_PORTS_ALL = TARGET_PORTS_BASIC + TARGET_PORTS_OSX

# TARGET_IP_ADDRESSES = ["127.0.0.1"] + ["192.168.2." + str(i) for i in range(1, 256)]
# TARGET_IP_ADDRESSES = ["127.0.0.1", "192.168.2.10", "192.168.2.5"]
TARGET_IP_ADDRESSES = ["127.0.0.1", "192.168.2.10", "192.168.2.5", "192.168.2.6", "192.168.2.7", "192.168.2.8", "192.168.2.1"]

class State(object):
    """Parent State class"""
    pass


# //////////////
# State_v0
# //////////////
class State_v0(State):
    """Basic data model.

    A state class for the basic operations. Helps
    monitor the system being tested.

    Parameters
    ----------
    sequence
        Basic type that's able to fit into a list. Typically int, bool, etc.

    Returns
    -------
    State_v0
        The state.
    """

    def __init__(self, *args):
        if args:
            if isinstance(args[0], int):
                self._sequence = [args[0]]
            elif isinstance(args[0], list):
                self._sequence = args[0]
        else:
            self._sequence = []

    def __str__(self):
        return str(self._sequence)

    def __add__(self, newstate):
        """Merge to stage objects"""
        return State_v0(self._sequence + newstate._sequence)


# //////////////
# State_v1
# //////////////
class ExploitState_v1(object):
    def __init__(self, type_exploit: object, launched: bool = False):
        self.type = type_exploit
        self.launched = launched

        # Instantiate a OneHotEncoder with output as dense array
        self.enc = OneHotEncoder(sparse_output=False)        
        self.exploits_enc = []
        for c in ef.exploits_all:
            self.exploits_enc.append(c.__name__)
        self.exploits_enc = np.array(self.exploits_enc).reshape(-1, 1)
        self.code = self.enc.fit_transform(self.exploits_enc)
    
    def __str__(self):
        return str(self.type) + "|" + str(self.launched)

    def __repr__(self) -> str:
        return self.__str__()
    
    def one_hot_encode(self):
        """
        One-hot encodes the 'type' instance variable and binary encodes the 'launched' instance variable.
        """
        type_processed = np.array([self.type.__name__]).reshape(-1, 1)
        type_encoded = self.enc.transform(type_processed)  # one-hot encode self.type, 2D np array
        type_encoded = type_encoded.flatten().tolist()      # flatten to 1D list

        # binary encode self.launched
        launched_encoded = [1.0 if self.launched else 0.0]
        return type_encoded + launched_encoded



class PortState_v1(object):
    def __init__(
        self,
        port: int,
        open: bool = False,
        name: str = None,
        version: str = None,
        cpe: str = None,
    ):
        self.port = port
        self.open = open
        self.name = name
        self.version = version
        self.cpe = cpe

        # Instantiate a OneHotEncoder with output as dense array
        self.enc = OneHotEncoder(sparse_output=False)        
        self.ports_enc = []
        for p in ef.state.TARGET_PORTS_BASIC:
            self.ports_enc.append(p)
        self.ports_enc = np.array(self.ports_enc).reshape(-1, 1)
        self.code = self.enc.fit_transform(self.ports_enc)

    
    def __str__(self):
        return str(self.port) + "|" + str(self.open)        

    def __repr__(self) -> str:
        return self.__str__()
    
    def one_hot_encode(self):
        # Assuming 'port' is categorical and 'open' is binary
        #
        #   'name', 'version', 'cpe' discarded for one-hot encoding
        port_processed = np.array([self.port]).reshape(-1, 1)
        port_encoded = self.enc.transform(port_processed)   # one-hot encode self.port, 2D np array
        port_encoded = port_encoded.flatten().tolist()      # flatten to 1D list

        # binary encode self.launched
        open_encoded = [1.0 if self.open else 0.0]
        return port_encoded + open_encoded
    

class State_v1(State):
    def __init__(self, *args):
        self.exploits = []
        self.ports = []

        # initialize all exploits as unlaunched (False)
        for c in ef.exploits_all:
            self.exploits.append(ExploitState_v1(c, False))
            # print(c.__name__)  # debug

        # initialize all ports to closed (False)
        for port in TARGET_PORTS_BASIC:
            self.ports.append(PortState_v1(port))

    def __str__(self):
        """Returns dict with launched exploits and open ports"""
        d_return = {"exploits": [], "ports": []}
        for expl in self.exploits:
            if expl.launched:
                if isinstance(expl.type, type):
                    # expl.type is a class
                    d_return["exploits"].append(str(expl.type.__name__))
                else:  
                    # expl.type is an obj
                    d_return["exploits"].append(str(expl.type.get_name()))

        for port in self.ports:
            if port.open:
                d_return["ports"].append(
                    "port: " + str(port.port) + ", name: " + str(port.name) + ", version: " + str(port.version)
                )
        return str(pprint.pformat(d_return))

    def __repr__(self) -> str:
        return self.__str__()

    def __add__(self, newstate):
        """Merge two state objects"""
        return newstate
    
    def one_hot_encode(self):
        # one-hot encode all ExploitState_v1 and PortState_v1 objects in 'exploits' and 'ports'
        exploits_encoded = [exploit.one_hot_encode() for exploit in self.exploits]
        flattened_exploits_encoded = [item for sublist in exploits_encoded for item in sublist]

        ports_encoded = [port.one_hot_encode() for port in self.ports]
        flattened_ports_encoded = [item for sublist in ports_encoded for item in sublist]

        # return ports_encoded + exploits_encoded
        return flattened_ports_encoded + flattened_exploits_encoded
        

# //////////////
# State_v2
#  dictionary of State_v2 wherein each key corresponds
#  with the IP address of the target
# //////////////
class State_v2(State):
    def __init__(self, *args):
        self.states = {}

        # initialize all states as empty
        for ip in TARGET_IP_ADDRESSES:
            self.add_new(ip)

    def add(self, ip: str, state: State_v1) -> None:
        self.states[ip] = state

    def add_new(self, ip: str) -> None:
        state = State_v1()
        self.states[ip] = state

    def merge(self, newstate, target="127.0.0.1") -> None:
        """
        Merges the current object with a new State

        Supports both State_v1 and State_v2.
        """
        if type(newstate) == State_v1:
            self.states[target] = newstate  # whether it exists or not            
        elif type(newstate) == State_v2:
            aux_state = self + newstate  # NOTE: overwrites self, with newstate
            self.states = aux_state.states
        else:
            raise TypeError("Unknown state type")

    def __add__(self, newstate):
        """
        Merge two state objects            
        """
        aux_state = copy.deepcopy(self)

        # # NOTE: Overwrites self with newstate
        # for ip in newstate.states.keys():
        #     aux_state.states[ip] = newstate.states[ip]
        # return newstate

        # NOTE: Adds each exploit and ports, for each ip
        for ip in newstate.states.keys():
            
            #if ip not in aux_state.states.keys(), add it
            if ip not in aux_state.states.keys():
                aux_state.add_new(ip)

            # check exploits to add
            for expl in newstate.states[ip].exploits:
                if expl.launched:
                    aux_state.states[ip].exploits.append(expl)

            # check ports to add
            for port in newstate.states[ip].ports:
                if port.open:
                    aux_state.states[ip].ports.append(port)
        return aux_state

    def __str__(self):
        """Returns dict with launched exploits and open ports"""
        return pprint.pformat(self.states)

    def __getitem__(self, key):
        return self.states[key]
    
    def __setitem__(self, key, value):
        self.states[key] = value

    def __repr__(self) -> str:
        return self.__str__()
    
    def one_hot_encode(self):
        # one-hot encode all State_v1 objects in 'states'
        states_encoded = [state.one_hot_encode() for state in self.states.values()]
        flattened_states_encoded = [item for sublist in states_encoded for item in sublist]
        # return states_encoded
        return flattened_states_encoded 

# //////////////
# State_v3
#
# NOTE, like State_v1, but using instances instead of classes
# //////////////
class ExploitState_v3(object):
    def __init__(self, type_exploit: object, launched: bool = False):
        self.type = type_exploit
        self.launched = launched

        # Instantiate a OneHotEncoder with output as dense array
        self.enc = OneHotEncoder(sparse_output=False)        
        self.exploits_enc = []
        for c in ef.exploits_all_instances:
            self.exploits_enc.append(c.get_name())
        self.exploits_enc = np.array(self.exploits_enc).reshape(-1, 1)
        self.code = self.enc.fit_transform(self.exploits_enc)
    
    def __str__(self):
        return str(self.type) + "|" + str(self.launched)

    def __repr__(self) -> str:
        return self.__str__()
    
    def one_hot_encode(self):
        """
        One-hot encodes the 'type' instance variable and binary encodes the 'launched' instance variable.
        """
        type_processed = np.array([self.type.name]).reshape(-1, 1)
        type_encoded = self.enc.transform(type_processed)  # one-hot encode self.type, 2D np array
        type_encoded = type_encoded.flatten().tolist()      # flatten to 1D list

        # binary encode self.launched
        launched_encoded = [1.0 if self.launched else 0.0]
        return type_encoded + launched_encoded



class PortState_v3(object):
    def __init__(
        self,
        port: int,
        open: bool = False,
        name: str = None,
        version: str = None,
        cpe: str = None,
    ):
        self.port = port
        self.open = open
        self.name = name
        self.version = version
        self.cpe = cpe

        # Instantiate a OneHotEncoder with output as dense array
        self.enc = OneHotEncoder(sparse_output=False)        
        self.ports_enc = []
        for p in ef.state.TARGET_PORTS_BASIC:
            self.ports_enc.append(p)
        self.ports_enc = np.array(self.ports_enc).reshape(-1, 1)
        self.code = self.enc.fit_transform(self.ports_enc)

    
    def __str__(self):
        return str(self.port) + "|" + str(self.open)        

    def __repr__(self) -> str:
        return self.__str__()
    
    def one_hot_encode(self):
        # Assuming 'port' is categorical and 'open' is binary
        #
        #   'name', 'version', 'cpe' discarded for one-hot encoding
        port_processed = np.array([self.port]).reshape(-1, 1)
        port_encoded = self.enc.transform(port_processed)   # one-hot encode self.port, 2D np array
        port_encoded = port_encoded.flatten().tolist()      # flatten to 1D list

        # binary encode self.launched
        open_encoded = [1.0 if self.open else 0.0]
        return port_encoded + open_encoded
    

class State_v3(State):
    def __init__(self, *args):
        self.exploits = []
        self.ports = []

        # initialize all exploits as unlaunched (False)
        for c in ef.exploits_all_instances:
            self.exploits.append(ExploitState_v3(c, False))
            # print(c.__name__)  # debug

        # initialize all ports to closed (False)
        for port in TARGET_PORTS_BASIC:
            self.ports.append(PortState_v1(port))

    def __str__(self):
        """Returns dict with launched exploits and open ports"""
        d_return = {"exploits": [], "ports": []}
        for expl in self.exploits:
            if expl.launched:
                if isinstance(expl.type, type):
                    # expl.type is a class
                    d_return["exploits"].append(str(expl.type.__name__))
                else:  
                    # expl.type is an obj
                    d_return["exploits"].append(str(expl.type.get_name()))

        for port in self.ports:
            if port.open:
                d_return["ports"].append(
                    "port: " + str(port.port) + ", name: " + str(port.name) + ", version: " + str(port.version)
                )
        return str(pprint.pformat(d_return))

    def __repr__(self) -> str:
        return self.__str__()

    def __add__(self, newstate):
        """Merge two state objects"""
        return newstate
    
    def one_hot_encode(self):
        # one-hot encode all ExploitState_v1 and PortState_v1 objects in 'exploits' and 'ports'
        exploits_encoded = [exploit.one_hot_encode() for exploit in self.exploits]
        flattened_exploits_encoded = [item for sublist in exploits_encoded for item in sublist]

        ports_encoded = [port.one_hot_encode() for port in self.ports]
        flattened_ports_encoded = [item for sublist in ports_encoded for item in sublist]

        # return ports_encoded + exploits_encoded
        return flattened_ports_encoded + flattened_exploits_encoded
        

# //////////////
# State_v4
#  like State_v2, but using instances instead of classes
# //////////////
class State_v4(State):
    def __init__(self, *args):
        self.states = {}

        # initialize all states as empty
        for ip in TARGET_IP_ADDRESSES:
            self.add_new(ip)

    def add(self, ip: str, state: State_v3) -> None:
        self.states[ip] = state

    def add_new(self, ip: str) -> None:
        state = State_v1()
        self.states[ip] = state

    def merge(self, newstate, target="127.0.0.1") -> None:
        """
        Merges the current object with a new State

        Supports both State_v1 and State_v2.
        """
        if type(newstate) == State_v3:
            self.states[target] = newstate  # whether it exists or not            
        elif type(newstate) == State_v4:
            aux_state = self + newstate  # NOTE: overwrites self, with newstate
            self.states = aux_state.states
        else:
            raise TypeError("Unknown state type")

    def __add__(self, newstate):
        """
        Merge two state objects            
        """
        aux_state = copy.deepcopy(self)

        # # NOTE: Overwrites self with newstate
        # for ip in newstate.states.keys():
        #     aux_state.states[ip] = newstate.states[ip]
        # return newstate

        # NOTE: Adds each exploit and ports, for each ip
        for ip in newstate.states.keys():
            
            #if ip not in aux_state.states.keys(), add it
            if ip not in aux_state.states.keys():
                aux_state.add_new(ip)

            # check exploits to add
            for expl in newstate.states[ip].exploits:
                if expl.launched:
                    aux_state.states[ip].exploits.append(expl)

            # check ports to add
            for port in newstate.states[ip].ports:
                if port.open:
                    aux_state.states[ip].ports.append(port)
        return aux_state

    def __str__(self):
        """Returns dict with launched exploits and open ports"""
        return pprint.pformat(self.states)

    def __getitem__(self, key):
        return self.states[key]
    
    def __setitem__(self, key, value):
        self.states[key] = value

    def __repr__(self) -> str:
        return self.__str__()
    
    def one_hot_encode(self):
        # one-hot encode all State_v1 objects in 'states'
        states_encoded = [state.one_hot_encode() for state in self.states.values()]
        flattened_states_encoded = [item for sublist in states_encoded for item in sublist]
        # return states_encoded
        return flattened_states_encoded 


def to_State(state: State, target: str) -> State_v2:
    """
    Returns a new State_v2 of state
    """    
    # ensure aux_state is State_v2
    if type(state) == State_v1:
        aux_state = State_v2()
        aux_state.add(target, state)
    elif type(state) == State_v3:
        aux_state = State_v4()
        aux_state.add(target, state)

    else:
        aux_state = copy.deepcopy(state)
    
    return aux_state


# //////////////
# Aliases
# //////////////

# State_default = State_v0
# State_default = State_v1
State_default = State_v2
# State_default = State_v4