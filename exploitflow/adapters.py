# Copyright 2022 VÃ­ctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# adapters are EF's connectors to other exploitation frameworks

import requests
from abc import abstractmethod
from pymetasploit3.msfrpc import MsfRpcClient
from pymetasploit3.msfconsole import MsfRpcConsole
from typing import List
from exploitflow import exploit
import threading


class Adapter(object):
    """
    The base adapter class

    Meant to be subclassed by each adapter
    """
    def __init__(self):
        self.initialized = False  # captures whether the adapter is initialized 
                                  # successfully or not. This often requires
                                  # clients to be initialized for communication
                                  # with other exploitation frameworks. 

    @abstractmethod
    def _reconaissance(self, *args, **kwargs) -> List[exploit.Exploit]:
        raise NotImplementedError

    @abstractmethod
    def get_name(self, *args, **kwargs) -> exploit.Exploit:
        raise NotImplementedError

    def get_reconnaissance(self) -> List[exploit.Exploit]:
        """
        Returns a list of exploits that can be used to perform reconnissance in the target.        
        """
        return self._reconaissance()


class AdapterMSF(Adapter):
    """MetaSploit Framework adapter"""

    def __init__(self):
        super().__init__()  # in case there's common code in the base class
        try:
            self.initialized = True

            # connect to MSF RPC server, see "devcontainer.json" for details on
            # how the server is configured
            self.client = MsfRpcClient('exploitflow', ssl=True)
            
            # # Create a new thread and run the console in that thread
            # thread = threading.Thread(target=self._launch_console, args=(self.client, self._read_console,))
            # thread.start()   
            self.console = self.client.consoles.console() # create a new MsfConsole

            # console variables
            self.console_status = None
            self.positive_out = []
            self.console_out = []

        except Exception as e:
            print("Error connecting to MSF RPC server: " + str(e))
            self.initialized = False

    # def _launch_console(self, client, callback):
    #     console = MsfRpcConsole(client, cb=callback)
    #     while 1:
    #         console = MsfRpcConsole(client, cb=callback)
    #         # console._poller()

    # def _read_console(self, console_data):
    #     self.console_status = console_data['busy']
    #     print("AdapterMSF callback status: " + str(self.console_status))

    #     # debug
    #     # log things out just in case
    #     sigdata = console_data['data'].rstrip().split('\n')
    #     for line in sigdata:            
    #         self.console_out.append(line)        

    #     if '[+]' in console_data['data']:
    #         sigdata = console_data['data'].rstrip().split('\n')
    #         for line in sigdata:
    #             if '[+]' in line:
    #                 self.positive_out.append(line)
    #         print(console_data['data'])


    def _reconaissance(self, *args, **kwargs) -> List[exploit.Exploit]:
            if not self.initialized:
                return []

            # Filter out some of the scan action available
            # will filter out: 
            # ['scanner/discovery/arp_sweep', 'scanner/discovery/empty_udp', 
            # 'scanner/discovery/ipv6_multicast_ping', 'scanner/discovery/ipv6_neighbor', 
            # 'scanner/discovery/ipv6_neighbor_router_advertisement', 'scanner/discovery/udp_probe', 
            # 'scanner/discovery/udp_sweep']

            candidate_names = [k for k in self.client.modules.auxiliary if 'scanner/discovery' in k]
            return [exploit.ExploitMSF(self, module, "auxiliary", {}) for module in candidate_names]


    def get_name(self, exploit_type, name) -> exploit.Exploit:
        """Returns the name of the exploit

            Arguments:
            - exploit_type: the exploit type (e.g. "auxiliary", or "exploit")
            - name: the name of the exploit (e.g. scanner/discovery/udp_sweep)
        """
        if not self.initialized:
            return None

        return exploit.ExploitMSF(self, name, exploit_type, {})