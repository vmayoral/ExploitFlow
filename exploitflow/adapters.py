# Copyright 2022 VÃ­ctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# adapters are EF's connectors to other exploitation frameworks

import requests
from abc import abstractmethod
from pymetasploit3.msfrpc import MsfRpcClient
from typing import List
from exploitflow import exploit


class Adapter(object):
    """
    The base adapter class

    Meant to be subclassed by each adapter
    """
    def __init__(self):
        self.initialized = False  # captures whether the adapter is initialized 
                                  # successfully or not. This often requires
                                  # clients to be initialized for communication
                                  # with other exploitation frameworks. 

    @abstractmethod
    def _reconaissance(self, *args, **kwargs) -> List[exploit.Exploit]:
        raise NotImplementedError

    def get_reconnaissance(self) -> List[exploit.Exploit]:
        """
        Returns a list of exploits that can be used to perform reconnissance in the target.        
        """
        return self._reconaissance()


class AdapterMSF(Adapter):
    """MetaSploit Framework adapter"""

    def __init__(self):
        super().__init__()  # in case there's common code in the base class
        try:
            # connect to MSF RPC server, see "devcontainer.json" for details on
            # how the server is configured
            self.client = MsfRpcClient('exploitflow', ssl=True)
            self.initialized = True

            # print(len(self.client.modules.auxiliary))  # number of MSF "exploits"
        except Exception:
            pass

    def _reconaissance(self, *args, **kwargs) -> List[exploit.Exploit]:
            if not self.initialized:
                return []

            # Filter out some of the scan action available
            # will filter out: 
            # ['scanner/discovery/arp_sweep', 'scanner/discovery/empty_udp', 
            # 'scanner/discovery/ipv6_multicast_ping', 'scanner/discovery/ipv6_neighbor', 
            # 'scanner/discovery/ipv6_neighbor_router_advertisement', 'scanner/discovery/udp_probe', 
            # 'scanner/discovery/udp_sweep']

            candidate_names = [k for k in self.client.modules.auxiliary if 'scanner/discovery' in k]
            return [exploit.ExploitMSF(self.client, module, {}) for module in candidate_names]

