# Copyright 2022 Víctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Access to this exploit and the use of information, materials (or portions
# thereof), is not intended, and is prohibited, where such access or use
# violates applicable laws or regulations.  By no means the authors
# encourage or promote the unauthorized tampering with running
# systems. This can cause serious human harm and material damages.

from exploitflow.killchain.reconnaissance import ReconnaissanceExploit
from exploitflow.state import *
from exploitflow.common import *
import json
import xmltodict
import copy
from wasabi import color
import pprint


class TargetsExploit(ReconnaissanceExploit):
    """
    Leverages Nmap to locate targets

    NOTE: exploit launches against all targets (and should be marked
    appropriately)
    """
    def __init__(self, subnet=None, name="TargetsExploit"):
        super(TargetsExploit, self).__init__(name)
        self.subnet = subnet

    def _forward(self, state_input, target, debug=False) -> State:
        if state_input:
            self.pre_state = state_input
        else:
            self.pre_state = State_default()  # New empty state

        # priotize exploit's target, over flow's target
        if self.target:
            flow_target = target
            target = self.target

        # if subnet passed as part of the constructor, use it
        # otherwise construct it from "target"
        target_subnet = None
        if self.subnet:
            target_subnet = self.subnet
        else:
            target_subnet = target + "/24"

        # manually invoke and process nmap XML output
        nmap_command = (
            "nmap -oX - -sn "
            + target_subnet
        )
        xml = shellout(nmap_command)
        nmap_results = xmltodict.parse(xml)

        # print(json.dumps(nmap_results, indent=4, sort_keys=True))  # debug

        # TODO: Note that if there's only one port, data structure is different
        # see https://avleonov.com/2018/03/11/converting-nmap-xml-scan-reports-to-json/
        # for an example
        
        # NOTE, turns input state into latest State and ensures
        # that it's not empty (add least state for target)
        aux_state = to_State(self.pre_state, target)
        if not aux_state.states:  # if dict states is empty
            aux_state.add_new(target)  # create a new state for target

        # extra reward
        # NOTE: adds a "-1" per each host that is up
        # since the goal is to remain stealthy
        extra_reward = 0

        for target_nmap in nmap_results["nmaprun"]["host"]:
            if target_nmap["status"]["@state"] == "up":
                # could come as a list or as a dict
                if type(target_nmap["address"]) == list:
                    ipaddr = str(target_nmap["address"][0]["@addr"])
                elif type(target_nmap["address"]) == dict:
                    ipaddr = str(target_nmap["address"]["@addr"])
                else:
                    raise Exception("Unknown data type for address")

                if not ipaddr in aux_state.states.keys():
                    aux_state.add_new(ipaddr)
                    extra_reward -= 1

        self.post_state = aux_state

        # mark exploit as launched, NOTE assumes post_state is PortState_v2 (or v4)
        for state_target in self.post_state.states.keys():
            # mark exploit as launched, NOTE assumes post_state is PortState_v2 (or v4)
            for i, exploit_state in enumerate(self.post_state.states[state_target].exploits):
                # print("DEBUG: " + str(exploit_state.type))
                if isinstance(exploit_state.type, type):  # if type is a class, PortState_v2 
                    if exploit_state.type == self.__class__:
                        self.post_state.states[state_target].exploits[i].launched = True
                else:                                     # if type is an object, PortState_v4
                    if exploit_state.type == self.name:
                        self.post_state.states[state_target].exploits[i].launched = True

        self.status = (
            nmap_results["nmaprun"]["runstats"]["finished"]["@exit"] == "success"
        )
        self.debug(debug, nmap_results=nmap_results, target=target)

        # NOTE add reward (and extra, if applicable) to the graph
        self.reward = self.reward + extra_reward
        # update graph        
        self._graph.update(self, self.reward, self.post_state, debug=debug)

        return self.post_state

    def debug(self, debug, nmap_results=None, target=None):
        if debug:
            super(ReconnaissanceExploit, self).debug(debug, target)
            # if nmap_results:
            #     for target_nmap in nmap_results["nmaprun"]["host"]:
            #         if target_nmap["status"]["@state"] == "up":
            #             ipaddr = str(target_nmap["address"][0]["@addr"])
            #             print("- " + ipaddr)