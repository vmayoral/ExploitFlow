# Copyright 2022 Víctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Access to this exploit and the use of information, materials (or portions
# thereof), is not intended, and is prohibited, where such access or use
# violates applicable laws or regulations.  By no means the authors
# encourage or promote the unauthorized tampering with running
# systems. This can cause serious human harm and material damages.

from exploitflow.killchain.reconnaissance import ReconnaissanceExploit
from exploitflow.state import *
from exploitflow.common import *
import json
import xmltodict
import copy
from wasabi import color


class VersionExploit(ReconnaissanceExploit):
    """
    Scan for versions in a given port-range
    """
    def __init__(self, ports=TARGET_PORTS_BASIC, name="VersionExploit"):
        super(VersionExploit, self).__init__(name)
        self.ports = ports

    def _forward(self, state_input, target, debug=False) -> State:
        if state_input:
            self.pre_state = state_input
        else:
            self.pre_state = State_default()  # New empty state

        # priotize exploit's target, over flow's target
        if self.target:
            flow_target = target
            target = self.target

        # manually invoke and process nmap XML output
        if self.ports:
            nmap_command = (
                "nmap -oX - -sV "
                + target
                + " -p "
                + "".join([str(x) + "," for x in self.ports])
            )
        else:
            nmap_command = (
                "nmap -oX - -sV "
                + target
                + " -p "
                + "".join([str(x) + "," for x in TARGET_PORTS_ALL])
            )
        xml = shellout(nmap_command)
        nmap_results = xmltodict.parse(xml)

        # print(json.dumps(nmap_results, indent=4, sort_keys=True))  # debug

        # TODO: Note that if there's only one port, data structure is different
        # see https://avleonov.com/2018/03/11/converting-nmap-xml-scan-reports-to-json/
        # for an example
        
        # NOTE, turns input state into State and ensures
        # that it's not empty (add least state for target)
        aux_state = to_State(self.pre_state, target)
        if not aux_state.states:  # if dict states is empty
            aux_state.add_new(target)  # create a new state for target

        # evaluate only if results for ports
        if "port" in nmap_results["nmaprun"]["host"]["ports"].keys():
            # consider if only one result,
            if type(nmap_results["nmaprun"]["host"]["ports"]["port"]) == dict:
                port = nmap_results["nmaprun"]["host"]["ports"]["port"]
                new_port = int(port["@portid"])
                version = (
                        port["service"]["@version"] if "@version" in port["service"] else None
                )
                name = port["service"]["@name"] if "@name" in port["service"] else None
                cpe = port["service"]["cpe"] if "cpe" in port["service"] else "unknown"
                new_port_state = PortState_v1(
                        new_port,
                        port["state"]["@state"] == "open",
                        name,
                        version,
                        cpe,
                )
                
                for i, state_port in enumerate(aux_state.states[target].ports):
                    if state_port.port == new_port:
                        aux_state.states[target].ports[i] = new_port_state

            else:
            # or multiple
                for port in nmap_results["nmaprun"]["host"]["ports"]["port"]:
                    new_port = int(port["@portid"])
                    version = (
                        port["service"]["@version"] if "@version" in port["service"] else None
                    )
                    name = port["service"]["@name"] if "@name" in port["service"] else None
                    # cpe = port["service"]["cpe"] if "cpe" in port["service"] else None
                    cpe = port["service"]["cpe"] if "cpe" in port["service"] else "unknown"
                    new_port_state = PortState_v1(
                        new_port,
                        port["state"]["@state"] == "open",
                        name,
                        version,
                        cpe,
                    )

                    # update, NOTE assumes aux_state is PortState_v2
                    for i, state_port in enumerate(aux_state.states[target].ports):
                        if state_port.port == new_port:
                            aux_state.states[target].ports[i] = new_port_state

        self.post_state = aux_state

        # mark exploit as launched, NOTE assumes post_state is PortState_v2 (or v4)
        for i, exploit_state in enumerate(self.post_state.states[target].exploits):
            # print("DEBUG: " + str(exploit_state.type))
            if isinstance(exploit_state.type, type):  # if type is a class, PortState_v2 
                if exploit_state.type == self.__class__:
                    self.post_state.states[target].exploits[i].launched = True
            else:                                     # if type is an object, PortState_v4
                if exploit_state.type == self.name:
                    self.post_state.states[target].exploits[i].launched = True

        self.status = (
            nmap_results["nmaprun"]["runstats"]["finished"]["@exit"] == "success"
        )
        self.debug(debug, nmap_results=nmap_results, target=target)

        # update graph
        self._graph.update(self, self.reward, self.post_state)        

        return self.post_state

    def debug(self, debug, nmap_results=None, target=None):
        if debug:
            super(ReconnaissanceExploit, self).debug(debug, target)

            # print(nmap_results)
            # if nmap_results:
            #     for port in nmap_results["nmaprun"]["host"]["ports"]["port"]:
            #         cpe = (
            #             port["service"]["cpe"]
            #             if "cpe" in port["service"]
            #             else "unknown"
            #         )
            #         print(
            #             str(port["@portid"])
            #             + " - "
            #             + str(port["state"]["@state"])
            #             + " - "
            #             + str(port["service"]["@name"])
            #             + " - "
            #             + str(port["service"]["@version"])
            #             + " - "
            #             + cpe
            #         )


class FakeVersionExploit(VersionExploit):
    def __init__(self, port_range=None, name="FakeVersionExploit"):
        super(FakeVersionExploit, self).__init__(name=name)

    def _forward(self, state, target, debug=False) -> State:
        # 1. define previous state
        if state:
            self.pre_state = state
        else:
            self.pre_state = State_default()  # New empty state
        
        # priotize exploit's target, over flow's target
        if self.target:
            flow_target = target
            target = self.target

        # 2. build next state
        #
        # NOTE, turns input state into the latest State and ensures
        # that it's not empty (add least state for target)
        aux_state_latest = to_State(self.pre_state, target)
        if not aux_state_latest.states:  # if dict states is empty
            aux_state_latest.add_new(target)  # create a new state for target

        ## 2.1 Add changes in states
        ## 2.1.1 State 1
        aux_state = aux_state_latest[target]  # use the __getitem__ method
        # 2.1.1.1 Add changes in ports
        aux_state.ports[0].open = True
        aux_state.ports[0].name = "fake"
        # -
        aux_state.ports[2].open = True
        aux_state.ports[2].name = "fake"
        # -
        aux_state.ports[10].open = True
        aux_state.ports[10].name = "fake"
        ## 2.1.1.2 Add changes in exploits
        for i, exploit_state in enumerate(aux_state.exploits):
            if exploit_state.type == self.__class__:
                aux_state.exploits[i].launched = True

        ## 2.1.1 State 2, invented
        aux_state_latest.add_new("127.0.0.2")
        aux_state = aux_state_latest["127.0.0.2"]  # use the __getitem__ method
        # 2.1.1.1 Add changes in ports
        aux_state.ports[0].open = True
        aux_state.ports[0].name = "fake"
        # -
        aux_state.ports[2].open = True
        aux_state.ports[2].name = "fake"
        # -
        aux_state.ports[10].open = True
        aux_state.ports[10].name = "fake"
        ## 2.1.1.2 Add changes in exploits
        for i, exploit_state in enumerate(aux_state.exploits):
            if exploit_state.type == self.__class__:
                aux_state.exploits[i].launched = True

        self.post_state = aux_state_latest

        # 3. Define exploit status
        self.status = True

        # 4. Return resulting state
        self.debug(debug, target=target)

        # update graph
        self._graph.update(self.reward, self.post_state, debug=debug)
        return self.post_state


class FakeVersionExploit2(FakeVersionExploit):
    def __init__(self, port_range=None, name="FakeVersionExploit2"):
        super(FakeVersionExploit2, self).__init__(name=name)
