# Copyright 2022 Víctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Access to this exploit and the use of information, materials (or portions
# thereof), is not intended, and is prohibited, where such access or use
# violates applicable laws or regulations.  By no means the authors
# encourage or promote the unauthorized tampering with running
# systems. This can cause serious human harm and material damages.

from exploitflow.killchain.reconnaissance import ReconnaissanceExploit
from exploitflow.state import *
from exploitflow.common import *
import json
import xmltodict
import copy
from wasabi import color


class VersionExploit(ReconnaissanceExploit):
    """
    Scan for versions in a given port-range
    """

    def __init__(self, ports=None, name="VersionExploit"):
        super(VersionExploit, self).__init__(name)
        self.ports = ports

    def _forward(self, state_input, target, debug=False) -> State:
        self.pre_state = state_input

        # manually invoke and process nmap XML output
        if self.ports:
            nmap_command = (
                "nmap -oX - -sV "
                + target
                + " -p "
                + "".join([str(x) + "," for x in self.ports])
            )
        else:
            nmap_command = (
                "nmap -oX - -sV "
                + target
                + " -p "
                + "".join([str(x) + "," for x in TARGET_PORTS_ALL])
            )
        xml = shellout(nmap_command)
        nmap_results = xmltodict.parse(xml)

        # print(json.dumps(nmap_results, indent=4, sort_keys=True))  # debug

        # TODO: Note that if there's only one port, data structure is different
        # see https://avleonov.com/2018/03/11/converting-nmap-xml-scan-reports-to-json/
        # for an example
        
        # NOTE, turns input state into State_v2 and ensures
        # that it's not empty (add least state for target)
        aux_state = to_v2(self.pre_state, target)
        if not aux_state.states:  # if dict states is empty
            aux_state.add_new(target)  # create a new state for target

        # consider if only one result,
        if type(nmap_results["nmaprun"]["host"]["ports"]["port"]) == dict:
            port = nmap_results["nmaprun"]["host"]["ports"]["port"]
            new_port = int(port["@portid"])
            version = (
                    port["service"]["@version"] if "@version" in port["service"] else None
            )
            name = port["service"]["@name"] if "@name" in port["service"] else None
            cpe = port["service"]["cpe"] if "cpe" in port["service"] else "unknown"
            new_port_state = PortState_v1(
                    new_port,
                    port["state"]["@state"] == "open",
                    name,
                    version,
                    cpe,
            )
            
            for i, state_port in enumerate(aux_state.states[target].ports):
                if state_port.port == new_port:
                    aux_state.states[target].ports[i] = new_port_state

        else:
        # or multiple
            for port in nmap_results["nmaprun"]["host"]["ports"]["port"]:
                new_port = int(port["@portid"])
                version = (
                    port["service"]["@version"] if "@version" in port["service"] else None
                )
                name = port["service"]["@name"] if "@name" in port["service"] else None
                # cpe = port["service"]["cpe"] if "cpe" in port["service"] else None
                cpe = port["service"]["cpe"] if "cpe" in port["service"] else "unknown"
                new_port_state = PortState_v1(
                    new_port,
                    port["state"]["@state"] == "open",
                    name,
                    version,
                    cpe,
                )

                # update, NOTE assumes aux_state is PortState_v2
                for i, state_port in enumerate(aux_state.states[target].ports):
                    if state_port.port == new_port:
                        aux_state.states[target].ports[i] = new_port_state


        # mark exploit as launched, NOTE assumes aux_state is PortState_v2
        for i, exploit_state in enumerate(aux_state.states[target].exploits):
            if exploit_state.type == self.__class__:
                aux_state.states[target].exploits[i].launched = True

        self.post_state = aux_state
        self.status = (
            nmap_results["nmaprun"]["runstats"]["finished"]["@exit"] == "success"
        )
        self.debug(debug, nmap_results=nmap_results, target=target)
        return self.post_state

    def debug(self, debug, nmap_results=None, target=None):
        if debug:
            super(ReconnaissanceExploit, self).debug(debug, target)

            if nmap_results:
                for port in nmap_results["nmaprun"]["host"]["ports"]["port"]:
                    cpe = (
                        port["service"]["cpe"]
                        if "cpe" in port["service"]
                        else "unknown"
                    )
                    print(
                        port["@portid"]
                        + " - "
                        + port["state"]["@state"]
                        + " - "
                        + port["service"]["@name"]
                        + " - "
                        + port["service"]["@version"]
                        + " - "
                        + cpe
                    )


class FakeVersionExploit(VersionExploit):
    def __init__(self, port_range=None, name="FakeVersionExploit"):
        super(FakeVersionExploit, self).__init__(name=name)

    def _forward(self, state, target, debug=False) -> State:
        # 1. define previous state
        self.pre_state = state

        # 2. build next state

        # NOTE, turns input state into State_v2 and ensures
        # that it's not empty (add least state for target)
        aux_state_v2 = to_v2(self.pre_state, target)
        if not aux_state_v2.states:  # if dict states is empty
            aux_state_v2.add_new(target)  # create a new state for target



        ## 2.1 Add changes in states
        ## 2.1.1 State 1
        aux_state = aux_state_v2[target]  # use the __getitem__ method
        # 2.1.1.1 Add changes in ports
        aux_state.ports[0].open = True
        aux_state.ports[0].name = "fake"
        # -
        aux_state.ports[2].open = True
        aux_state.ports[2].name = "fake"
        # -
        aux_state.ports[10].open = True
        aux_state.ports[10].name = "fake"
        ## 2.1.1.2 Add changes in exploits
        for i, exploit_state in enumerate(aux_state.exploits):
            if exploit_state.type == self.__class__:
                aux_state.exploits[i].launched = True

        ## 2.1.1 State 2, invented
        aux_state_v2.add_new("127.0.0.2")
        aux_state = aux_state_v2["127.0.0.2"]  # use the __getitem__ method
        # 2.1.1.1 Add changes in ports
        aux_state.ports[0].open = True
        aux_state.ports[0].name = "fake"
        # -
        aux_state.ports[2].open = True
        aux_state.ports[2].name = "fake"
        # -
        aux_state.ports[10].open = True
        aux_state.ports[10].name = "fake"
        ## 2.1.1.2 Add changes in exploits
        for i, exploit_state in enumerate(aux_state.exploits):
            if exploit_state.type == self.__class__:
                aux_state.exploits[i].launched = True

        self.post_state = aux_state_v2

        # 3. Define exploit status
        self.status = True

        # 4. Return resulting state
        self.debug(debug, target=target)
        return self.post_state
