# Copyright 2022 VÃ­ctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Inspired by https://github.com/tobegit3hub/miniflow

from abc import ABCMeta, abstractmethod
import logging
import math
import os
import sys


from . import graph
from . import state
from wasabi import color


class Exploit(object):
    """
    The basic class for all operation.

    Attributes
    ----------
    name: str
        name of the exploit instances
    pre_state : state.State
        state of the flow before executing the exploit
    post_state : state.State
        state of the flow after executing the exploit
    status : bool
        success (True) or failure (False) after running the exploit
    run : bool
        captures whether the exploit has been run already
    reward: float
        reward that an attacker gets for executing the exploit

    Methods
    -------
    forward(self, *args, **kwargs) -> state.State:
        Flow forward pass frontend. Accounts for past runs.
    _forward(self, *args, **kwargs) -> state.State:
        Flow forward pass logic.
    force_forward(self, *args, **kwargs) -> state.State:
        Force forward pass logic without accounting for past runs.
    mitigate(self) -> bool:
        Execute exploit mitigation. Assumes it runs natively in the affected machine.

    """

    def __init__(self, name="Exploit"):
        self.name = name

        # state
        self.pre_state = None
        self.post_state = None

        # status
        self.status = False
        self.run = False

        # reward
        self.reward = -1  # discourage default use

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def forward(self, *args, **kwargs) -> state.State:
        if self.run:
            return self.post_state
        self.run = True  # first to account for recursive calls
        return self._forward(*args, **kwargs)

    @abstractmethod
    def _forward(self, *args, **kwargs) -> state.State:
        # TODO: No need to implement in abstract method
        raise NotImplementedError

    def force_forward(self, *args, **kwargs) -> state.State:
        # TODO: Rewrite in subclasses if necessary
        self._forward(*args, **kwargs)

    def mitigate(self) -> bool:
        return False

    def __str__(self):
        return str(self.name)

    def __add__(self, other):
        return AddExploit(self, other)

    def __radd__(self, other):
        return self.__add__(other)

    def __mul__(self, other):
        return MultipleExploit(self, other)

    def __rmul__(self, other):
        return self.__mul__(other)

    def debug(self, debug, target=None):
        if debug:
            debug_str = (
                color(
                    "Debugging " + self.get_name(),
                    fg="white",
                    bg="green",
                    bold=True,
                )
                + color(
                    " post_state: " + str(self.post_state),
                    fg="black",
                    bg="white",
                    bold=True,
                )
                + color(
                    " status: " + str(self.status),
                    fg="black",
                    bg="yellow",
                    bold=True,
                )
            )
            if target:
                debug_str += color(
                    " target: " + str(target),
                    fg="black",
                    bg="red",
                    bold=True,
                )
            print(debug_str)


class PlaceholderExploit(Exploit):
    """The placeholer operation"""

    def __init__(self, dtype=None, shape=None, name="Placeholder"):
        super(PlaceholderExploit, self).__init__(name)
        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def _forward(self, state, target, debug=False):
        self.pre_state = state
        self.post_state = state
        self.status = True  # always succeed
        self.debug(debug)
        return self.post_state


class InitExploit(PlaceholderExploit):
    """The initial placeholer for a exploit flow"""

    def __init__(self, name="Init"):
        super(PlaceholderExploit, self).__init__(name)
        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def _forward(self, state_input, target, debug=False):
        self.status = True  # always succeed Init Exploit
        self.pre_state = None
        self.post_state = state.State()
        self.debug(debug)
        return self.post_state


class BoolExploit(Exploit):
    """
    An Exploit that does nothing to the state and captures a bool value in its status.

    NOTE: doesn't add anything to the state
    """

    def __init__(self, boolean=True, name="Bool"):
        super(BoolExploit, self).__init__(name)
        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)
        self.status = boolean

    def _forward(self, state, target, debug=False):
        self.pre_state = state
        self.post_state = self.pre_state
        self.debug(debug)
        return self.post_state


class ConstantExploit(Exploit):
    """The constant operation which contains one initialized value."""

    def __init__(self, value, name="Constant"):
        super(ConstantExploit, self).__init__(name)
        self._value = value

        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def get_value(self):
        return self._value

    def _forward(self, input, target, debug=False):
        self.status = True  # always succeed
        self.pre_state = input
        if self.pre_state:
            self.post_state = self.pre_state + state.State(self._value)
        else:
            self.post_state = state.State(self._value)
        self.debug(debug, target)
        return self.post_state


class VariableExploit(Exploit):
    """
    The variable operation which contains one variable. The variable may be
    trainable or not-trainable. This is used to define the machine learning
    models.
    """

    def __init__(self, value, is_trainable=True, name="Variable"):
        super(VariableExploit, self).__init__(name)
        self._value = value
        self._is_trainable = is_trainable

        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

        if self._is_trainable:
            self._graph.add_to_trainable_variables_collection(self.get_name(), self)

    def get_value(self):
        return self._value

    def set_value(self, value):
        self._value = value

    def _forward(self, state, target, debug=False):
        self.status = True  # always succeed
        self.pre_state = state
        self.post_state = self.pre_state + state.State(self._value)

        self.run = False  # setting run to False forces a re-run next time
        # this is necessary since "VariableExploit" internals
        # could change (are variable)

        self.debug(debug)
        return self.post_state


class GlobalVariablesInitializerExploit(Exploit):
    def __init__(self, name="GlobalVariablesInitializer"):
        super(GlobalVariablesInitializerExploit, self).__init__(name)

        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def _forward(self):
        pass


class LocalVariablesInitializerExploit(Exploit):
    def __init__(self, name="LocalVariablesInitializer"):
        super(LocalVariablesInitializerExploit, self).__init__(name)

        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def _forward(self):
        pass


def get_variable(
    name="Variable",
    value=None,
    shape=None,
    dtype=None,
    initializer=None,
    regularizer=None,
    reuse=None,
    trainable=True,
):
    # TODO: Support default graph only
    _graph = graph.get_default_graph()

    if name in _graph.get_name_op_map():
        return _graph.get_name_op_map()[name]
    else:
        return VariableExploit(value=value, name=name)


class MultipleExploit(Exploit):
    """
    Mixes exploits propagating status in a serial manner.
    """

    def __init__(self, input1, input2, name="Mul"):
        super(MultipleExploit, self).__init__(name)
        self._op1 = (
            ConstantExploit(input1) if not isinstance(input1, Exploit) else input1
        )
        self._op2 = (
            ConstantExploit(input2) if not isinstance(input2, Exploit) else input2
        )
        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def _forward(self, state_input, target, debug=False):
        result1 = self._op1.forward(state_input, target, debug)
        result2 = self._op2.forward(result1, target, debug)
        self.status = self._op1.status and self._op2.status
        self.pre_state = state_input
        self.post_state = result2

        # graph
        self._graph.add_edge(
            self._op1, self._op2, label=str(result1)
        )  # edge between ops
        self._graph.add_edge(
            self._op2, self, label=str(self.post_state)
        )  # edge between second op and addition

        if debug:
            print(
                color(
                    "Debugging "
                    + str(self.get_name())
                    + " - "
                    + str(self._op1)
                    + " ["
                    + str(result1)
                    + "]"
                    + " (op1) and "
                    + str(self._op2)
                    + " ["
                    + str(result2)
                    + "]"
                    + " (op2): ",
                    fg="white",
                    bg="green",
                    bold=True,
                )
                + color(
                    " post_state: " + str(self.post_state),
                    fg="black",
                    bg="white",
                    bold=True,
                )
                + color(
                    " status: " + str(self.status),
                    fg="black",
                    bg="yellow",
                    bold=True,
                )
            )
        return self.post_state


class AddExploit(Exploit):
    """
    Mixes exploits propagating status in a serial manner.
    """

    def __init__(self, input1, input2, name="Add"):
        super(AddExploit, self).__init__(name)
        self._op1 = (
            ConstantExploit(input1) if not isinstance(input1, Exploit) else input1
        )
        self._op2 = (
            ConstantExploit(input2) if not isinstance(input2, Exploit) else input2
        )
        self._graph = graph.get_default_graph()
        self._graph.add_to_graph(self)

    def _forward(self, state_input, target, debug=False):
        result1 = self._op1.forward(state_input, target, debug)
        result2 = self._op2.forward(state_input, target, debug)

        self.status = self._op1.status or self._op2.status
        self.pre_state = state_input
        self.post_state = result1 + result2

        # graph
        self._graph.add_edge(self._op1, self)
        self._graph.add_edge(self._op2, self)

        if debug:
            print(
                color(
                    "Debugging "
                    + str(self.get_name())
                    + " - "
                    + str(self._op1)
                    + " ["
                    + str(result1)
                    + "]"
                    + " (op1) and "
                    + str(self._op2)
                    + " ["
                    + str(result2)
                    + "]"
                    + " (op2): ",
                    fg="white",
                    bg="green",
                    bold=True,
                )
                + color(
                    " post_state: " + str(self.post_state),
                    fg="black",
                    bg="white",
                    bold=True,
                )
                + color(
                    " status: " + str(self.status),
                    fg="black",
                    bg="yellow",
                    bold=True,
                )
            )
        return self.post_state
