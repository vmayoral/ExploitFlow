# Copyright 2022 Víctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Inspired by https://github.com/tobegit3hub/miniflow

from abc import ABCMeta, abstractmethod
import logging
import math
import os
import sys
from . import graph
from . import state
from wasabi import color


class Exploit(object):
    """
    The basic class for all operation.

    Attributes
    ----------
    name: str
        name of the exploit instances
    pre_state : state.State
        state of the flow before executing the exploit
    post_state : state.State
        state of the flow after executing the exploit
    status : bool
        success (True) or failure (False) after running the exploit
    run : bool
        captures whether the exploit has been run already
    reward: float
        reward that an attacker gets for executing the exploit
    target: str
        target of the exploit, each exploit may have a target that overwrites the
        default flow's target for that particular exploit

    Methods
    -------
    forward(self, *args, **kwargs) -> state.State:
        Flow forward pass frontend. Accounts for past runs.
    _forward(self, *args, **kwargs) -> state.State:
        Flow forward pass logic.
    force_forward(self, *args, **kwargs) -> state.State:
        Force forward pass logic without accounting for past runs.
    mitigate(self) -> bool:
        Execute exploit mitigation. Assumes it runs natively in the affected machine.

    """

    def __init__(self, name="Exploit"):
        self.name = name

        # state
        self.pre_state = None
        self.post_state = None

        # status
        self.status = False
        self.run = False

        # reward
        self.reward = -1  # default reward

        # target
        self.target = None

        # soft-reset is done by setting the attribute below to true
        # this is useful for exploits that are run multiple times
        # in the same flow, e.g. when trying to brute-force a password
        #
        # NOTE: this is not a good practice, but it's useful for testing
        # and specifically for simulation involving AI, wherein rollouts
        # and backpropagation are done multiple times
        self.soft_reset = False

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def forward(self, *args, **kwargs) -> state.State:
        # Extract the 'debug' argument from kwargs, if it doesn't exist it defaults to False
        debug = kwargs.get('debug', False)


        if self.soft_reset:
            # This way we trigger the run flag below in the next iteration,
            self.run = True
            self.soft_reset = False  # unset the soft_reset flag, net iteration
                                     # will run as usual

            self.debug(debug)
            self._graph.add_to_graph(self)
            self._graph.update(self, -1* self.reward, self.post_state, debug=debug)
            # NOTE: negate the reward to obtain positive result the first iterations
            return self.post_state

        # if run already, do not do it again, just used cached results
        if self.run:
            self.debug(debug)
            self._graph.add_to_graph(self)
            self._graph.update(self, self.reward, self.post_state, debug=debug)
            return self.post_state
        

        self.run = True  # NOTE: this should be done at the "_forward" level
                         # of each invididual exploit, but it's done here
                         # for convenience
                         # NOTE 2: a more realistic scenario would be to remove
                         # completely this, and/or periodically reseting it for
                         # better simulation of real-world scenarios

        return self._forward(*args, **kwargs)

    @abstractmethod
    def _forward(self, *args, **kwargs) -> state.State:
        # TODO: No need to implement in abstract method
        raise NotImplementedError

    def force_forward(self, *args, **kwargs) -> state.State:
        # TODO: Rewrite in subclasses if necessary
        self._forward(*args, **kwargs)

    def mitigate(self) -> bool:
        return False

    def __str__(self):
        return str(self.name)

    def __add__(self, other):
        return AddExploit(self, other)

    def __radd__(self, other):
        return self.__add__(other)

    def __mul__(self, other):
        return MultipleExploit(self, other)

    def __rmul__(self, other):
        return self.__mul__(other)

    def debug(self, debug, target=None):
        if debug:
            debug_str = (
                color(
                    "Debugging " + self.get_name(),
                    fg="white",
                    bg="green",
                    bold=True,
                )
                + color(
                    " pre_state: " + str(self.pre_state),
                    fg="black",
                    bg="grey",
                    bold=True,
                )
                + color(
                    " post_state: " + str(self.post_state),
                    fg="black",
                    bg="white",
                    bold=True,
                )
                + color(
                    " status: " + str(self.status),
                    fg="black",
                    bg="yellow",
                    bold=True,
                )
            )
            if target:
                debug_str += color(
                    " target: " + str(target),
                    fg="black",
                    bg="red",
                    bold=True,
                )
            print(debug_str)


class PlaceholderExploit(Exploit):
    """The placeholer operation"""

    def __init__(self, dtype=None, shape=None, name="Placeholder"):
        super(PlaceholderExploit, self).__init__(name)
        self._graph = graph.get_default_graph()

    def _forward(self, state, target, debug=False):
        self._graph.add_to_graph(self)
        self.pre_state = state
        self.post_state = state
        self.status = True  # always succeed
        self.debug(debug)        
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class InitExploit(PlaceholderExploit):
    """The initial placeholer for a exploit flow"""

    def __init__(self, name="Init"):
        super(PlaceholderExploit, self).__init__(name)
        self._graph = graph.get_default_graph()
        self.reward = 0  # exceptionally, don't discount

    def _forward(self, state_input, target, debug=False):
        self._graph.add_to_graph(self)
        self.status = True  # always succeed Init Exploit
        self.pre_state = None
        self.post_state = self._graph.state_class()
        self.debug(debug)
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class EndExploit(PlaceholderExploit):
    """The initial placeholer for a exploit flow"""

    def __init__(self, name="End"):
        super(PlaceholderExploit, self).__init__(name)
        self._graph = graph.get_default_graph()

    def _forward(self, state_input, target, debug=False):
        self.reward = 0  # exceptionally, don't discount
        self._graph.add_to_graph(self)
        self.status = True  # always succeed Init Exploit
        self.pre_state = state_input
        self.post_state = None
        self.debug(debug)
        self._graph.update(self, self.reward, self.pre_state, debug)
        return self.post_state
    

class IdleExploit(PlaceholderExploit):
    """An exploit that does nothing, nor impacts the reward"""

    def __init__(self, name="Idle"):
        super(PlaceholderExploit, self).__init__(name)
        self._graph = graph.get_default_graph()
        self.reward = 0  # exceptionally, don't discount

    def _forward(self, state_input, target, debug=False):
        self._graph.add_to_graph(self)

        # priotize exploit's target, over flow's target
        if self.target:
            flow_target = target
            target = self.target

        self.status = True  # always succeed

        # if no pre_state, create blank one
        if state_input:
            self.pre_state = state_input
        else:            
            self.pre_state = state.State_default()  # New empty state
        self.post_state = self.pre_state

        if target not in self.post_state.states.keys():  # if dict states is empty
            self.post_state.add_new(target)  # create a new state for target

        # mark exploit as launched, NOTE assumes post_state is PortState_v2 (or v4)
        for i, exploit_state in enumerate(self.post_state.states[target].exploits):
            # print("DEBUG: " + str(exploit_state.type))
            if isinstance(exploit_state.type, type):  # if type is a class, PortState_v2 
                if exploit_state.type == self.__class__:
                    self.post_state.states[target].exploits[i].launched = True
            else:                                     # if type is an object, PortState_v4
                if exploit_state.type == self.name:
                    self.post_state.states[target].exploits[i].launched = True

        self.debug(debug)        
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class BoolExploit(Exploit):
    """
    An Exploit that does nothing to the state and captures a bool value in its status.

    NOTE: doesn't add anything to the state
    """

    def __init__(self, boolean=True, name="Bool"):
        super(BoolExploit, self).__init__(name)
        self._graph = graph.get_default_graph()
        self.status = boolean

    def _forward(self, state, target, debug=False):
        self._graph.add_to_graph(self)
        self.pre_state = state
        self.post_state = self.pre_state
        self.debug(debug)
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class StateExploit(Exploit):
    """A exploit which abstracts a state."""

    def __init__(self, state, name="State"):
        super(StateExploit, self).__init__(name)
        self.pre_state = None
        self.post_state = state
        self._graph = graph.get_default_graph()
        self.reward = 0  # exceptionally, don't discount

    def _forward(self, input, target, debug=False):
        self._graph.add_to_graph(self)
        self.status = True  # always succeed
        self.pre_state = input
        if self.pre_state:
            self.post_state = self.pre_state + self.post_state
        else:
            pass  # do nothing
        
        self.debug(debug, target)
        self._graph.update(self, self.reward, self.post_state, auxiliary=True, debug=debug)
        return self.post_state


class ConstantExploit(Exploit):
    """The constant operation which contains one initialized value."""

    def __init__(self, value, name="Constant"):
        super(ConstantExploit, self).__init__(name)
        self._value = value

        self._graph = graph.get_default_graph()

    def get_value(self):
        return self._value

    def _forward(self, input, target, debug=False):
        self._graph.add_to_graph(self)
        self.status = True  # always succeed
        self.pre_state = input
        if self.pre_state:
            self.post_state = self.pre_state + self._graph.state_class(self._value)
        else:
            self.post_state = self._graph.state_class(self._value)
        self.debug(debug, target)
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class VariableExploit(Exploit):
    """
    The variable operation which contains one variable. The variable may be
    trainable or not-trainable. This is used to define the machine learning
    models.
    """

    def __init__(self, value, is_trainable=True, name="Variable"):
        super(VariableExploit, self).__init__(name)
        self._value = value
        self._is_trainable = is_trainable

        self._graph = graph.get_default_graph()

        if self._is_trainable:
            self._graph.add_to_trainable_variables_collection(self.get_name(), self)

    def get_value(self):
        return self._value

    def set_value(self, value):
        self._value = value

    def _forward(self, state, target, debug=False):
        self._graph.add_to_graph(self)
        self.status = True  # always succeed
        self.pre_state = state
        self.post_state = self.pre_state + self._graph.state_class(self._value)

        self.run = False  # setting run to False forces a re-run next time
        # this is necessary since "VariableExploit" internals
        # could change (are variable)

        self.debug(debug)
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class GlobalVariablesInitializerExploit(Exploit):
    def __init__(self, name="GlobalVariablesInitializer"):
        super(GlobalVariablesInitializerExploit, self).__init__(name)

        self._graph = graph.get_default_graph()

    def _forward(self):
        self._graph.add_to_graph(self)
        self._graph.update(self, self.reward, self.post_state, debug)
        pass


class LocalVariablesInitializerExploit(Exploit):
    def __init__(self, name="LocalVariablesInitializer"):
        super(LocalVariablesInitializerExploit, self).__init__(name)

        self._graph = graph.get_default_graph()

    def _forward(self):
        self._graph.add_to_graph(self)
        self._graph.update(self, self.reward, self.post_state, debug)
        pass


def get_variable(
    name="Variable",
    value=None,
    shape=None,
    dtype=None,
    initializer=None,
    regularizer=None,
    reuse=None,
    trainable=True,
):
    # TODO: Support default graph only
    _graph = graph.get_default_graph()

    if name in _graph.get_name_op_map():
        return _graph.get_name_op_map()[name]
    else:
        return VariableExploit(value=value, name=name)


class MultipleExploit(Exploit):
    """
    Mixes exploits propagating status in a serial manner.
    """

    def __init__(self, input1, input2, name="Mul"):
        super(MultipleExploit, self).__init__(name)
        self._graph = graph.get_default_graph()

        if not isinstance(input1, Exploit):
            self._op1 = StateExploit(input1)
            # add label and edge, recovered from run-ning again
            self._graph.add_edge(self._graph.last_action, self._op1, label="run")
        else: 
            self._op1 = input1
        
        if not isinstance(input2, Exploit):
            self._op2 = StateExploit(input2)
            # add label and edge, recovered from run-ning again
            self._graph.add_edge(self._graph.last_action, self._op2, label="run")
        else: 
            self._op2 = input2
        
        self.reward = 0  # exceptionally, don't discount

    def _forward(self, state_input, target, debug=False):
        self._graph.add_to_graph(self)
        result1 = self._op1.forward(state_input, target, debug=debug)
        result2 = self._op2.forward(result1, target, debug=debug)
        
        self.status = self._op1.status and self._op2.status
        self.pre_state = state_input
        self.post_state = result2

        graph
        self._graph.add_edge(
            self._op1, self._op2, label=str(result1)
        )  # edge between ops
        self._graph.add_edge(
            self._op2, self, label=str(self.post_state)
        )  # edge between second op and addition

        # if isinstance(self._op1, StateExploit):
        #     self._graph.add_edge(
        #         self._op1, self._op2, label=str(result1)
        #     )  # edge between ops
        #     self._graph.add_edge(
        #         self._op2, self, label=str(self.post_state)
        #     )  # edge between second op and addition
        # elif isinstance(self._op2, StateExploit):
        #     self._graph.add_edge(
        #         self._op2, self._op1, label=str(result1)
        #     )  # edge between ops
        #     self._graph.add_edge(
        #         self, self._op2, label=str(self.post_state)
        #     )  # edge between second op and addition
        # else:  # none of them are States
        #     self._graph.add_edge(
        #         self._op1, self._op2, label=str(result1)
        #     )  # edge between ops
        #     self._graph.add_edge(
        #         self._op2, self, label=str(self.post_state)
        #     )  # edge between second op and addition

        if debug:
            print(
                color(
                    "Debugging "
                    + str(self.get_name())
                    + " - "
                    + str(self._op1)
                    + " ["
                    + str(result1)
                    + "]"
                    + " (op1) and "
                    + str(self._op2)
                    + " ["
                    + str(result2)
                    + "]"
                    + " (op2): ",
                    fg="white",
                    bg="green",
                    bold=True,
                )
                + color(
                    " post_state: " + str(self.post_state),
                    fg="black",
                    bg="white",
                    bold=True,
                )
                + color(
                    " status: " + str(self.status),
                    fg="black",
                    bg="yellow",
                    bold=True,
                )
            )
        self._graph.update(self, self.reward, self.post_state, auxiliary=True, debug=debug)
        return self.post_state


class AddExploit(Exploit):
    """
    Mixes exploits propagating status in a serial manner.
    """

    def __init__(self, input1, input2, name="Add"):
        super(AddExploit, self).__init__(name)
        self._op1 = (
            StateExploit(input1) if not isinstance(input1, Exploit) else input1
        )
        self._op2 = (
            StateExploit(input2) if not isinstance(input2, Exploit) else input2
        )
        self._graph = graph.get_default_graph()
        self.reward = 0  # exceptionally, don't discount

    def _forward(self, state_input, target, debug=False):
        self._graph.add_to_graph(self)
        result1 = self._op1.forward(state_input, target, debug=debug)
        result2 = self._op2.forward(state_input, target, debug=debug)

        self.status = self._op1.status or self._op2.status
        self.pre_state = state_input
        self.post_state = result1 + result2

        # graph
        self._graph.add_edge(self._op1, self)
        self._graph.add_edge(self._op2, self)

        if debug:
            print(
                color(
                    "Debugging "
                    + str(self.get_name())
                    + " - "
                    + str(self._op1)
                    + " ["
                    + str(result1)
                    + "]"
                    + " (op1) and "
                    + str(self._op2)
                    + " ["
                    + str(result2)
                    + "]"
                    + " (op2): ",
                    fg="white",
                    bg="green",
                    bold=True,
                )
                + color(
                    " post_state: " + str(self.post_state),
                    fg="black",
                    bg="white",
                    bold=True,
                )
                + color(
                    " status: " + str(self.status),
                    fg="black",
                    bg="yellow",
                    bold=True,
                )
            )
        self._graph.update(self, self.reward, self.post_state, debug)
        return self.post_state


class ExploitMSF(Exploit):
    """
    A class to organize MSF exploits and other actions

    Coded so that it's generic across all MSF possible actions.

    Arguments are passed as a dictionary and then into MSF
    through the client before running (_forward) the exploit.

    Attributes
    ----------
    adapter: AdapterMSF
        The adapter for the MSF framework, helps interact with it
    name : str
        name of the exploit according to MSF nomenclature
    exploit_type : state.State
        type of MSF exploit (e.g. "auxiliary" or "exploit")
    args : dict
        MSF exploit arguments as a dict

    NOTE: arguments are initialized to an empty dic by default
    """

    def __init__(self, adapter, name, exploit_type, args):
        super(ExploitMSF, self).__init__(name)
        self._adapter = adapter
        self._type = exploit_type
        self._graph = graph.get_default_graph()
        self._exploit = self._adapter.client.modules.use(self._type, self.name)

        # redefine rewards
        # NOTE: these can be overwritten externally, if desired
        #
        self.reward = -10  # default exploit reward
        self.success_reward = 50  # reward for successful exploit

        # set arguments/options
        for key in args.keys():
            self._exploit[key] = args[key]

    def __str__(self):
        return super().__str__()

    def __repr__(self):
        return super().__str__()

    def get_options(self):
        return self._exploit.options

    def set_options(self, args):
        for key in args.keys():
            self._exploit[key] = args[key]

    def missing(self):
        """Report on any missing required arguments"""
        return None if not self._exploit.missing_required else self._exploit.missing_required

    def _forward(self, state_input, target, debug=False):
        # reward to apply, default to negative
        reward = self.reward
        
        if state_input:
            self.pre_state = state_input
        else:
            self.pre_state = state.State_default()  # New empty state
        
        self._graph.add_to_graph(self)

        # priotize exploit's target, over flow's target
        if self.target:
            flow_target = target
            target = self.target

        # execute the exploit (NOTE: blocking call)
        exploit_out = self._adapter.console.run_module_with_output(self._exploit)

        # # debug
        # print(exploit_out)

        # TODO: Consider more exploits as necessary in here
        if self.name == "scanner/discovery/arp_sweep":
            # process data and extract new IPs

            aux_state = state.State_default()  # to be filled by the exploit processing
                                        # routine below

            data = exploit_out.rstrip().split('\n')
            ips = []
            for line in data:
                if '[+]' in line:
                    line = line.replace("[+] ", "")
                    if "appears to be up" in line:
                        line = line.split(" appears to be up")
                        ips.append(line[0])

            for ip in ips:
                aux_state.add_new(ip)

            # Turn post_state into the latest State (State_v2, State_v4, as appropriate) 
            # by converting and then merging
            pre_state_aux = state.to_State(self.pre_state, target)
            pre_state_aux.merge(aux_state, target)  # NOTE: overwrites pre_state_aux with aux_state

            # NOTE: Since ExploitMSF is not included into exploits_all 
            # (which requires a class per each different exploit),
            # we add it in here to all targets and mark it as launched for 
            # the target in particular            
            for state_target in aux_state.states.keys():
                if state_target == target:
                    aux_state.states[state_target].exploits.append(
                        state.ExploitState_v1(self, True))
                else:
                    aux_state.states[state_target].exploits.append(
                        state.ExploitState_v1(self, False))

            self.post_state = aux_state

        else:
            if '[+]' in exploit_out:
                sigdata = exploit_out.rstrip().split('\n')
                for line in sigdata:
                    if '[+]' in line:
                        # print(line)  # Exploit succeeded
                        print(color(line, fg="white", bg="green"))
                        reward *= -1  # negate reward for positive, successful exploit

            self.post_state = self.pre_state  # no change

        # if no pre_state, create blank one
        if not self.post_state:
            self.post_state = state.State_default()

        if not self.post_state.states:          # if dict states is empty
            self.post_state.add_new(target)     # create a new state for target
        
        # mark exploit as launched, NOTE assumes post_state is PortState_v2 (or v4)
        for i, exploit_state in enumerate(self.post_state.states[target].exploits):
            # print("DEBUG: " + str(exploit_state.type))
            if isinstance(exploit_state.type, type):  # if type is a class, PortState_v2 
                if exploit_state.type == self.__class__:
                    self.post_state.states[target].exploits[i].launched = True
            else:                                     # if type is an object, PortState_v4
                if exploit_state.type == self.name:
                    self.post_state.states[target].exploits[i].launched = True

        self.status = True  # always succeed

        self.debug(debug, target)
        self._graph.update(self, reward, self.post_state, debug=debug)
        return self.post_state
