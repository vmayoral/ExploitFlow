# Copyright 2022 Víctor Mayoral-Vilches. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Inspired by https://github.com/tobegit3hub/miniflow

import logging
import requests
import networkx as nx
from . import exploit
from .state import State_default


class Graph(nx.DiGraph):
    """
    A graph storing every discrete step in the exploitation flow.

    Uses networkx, resources:
    - source code https://github.com/networkx/networkx
    - algorithms https://networkx.org/documentation/stable/reference/algorithms/index.html
    - tutorial https://networkx.org/documentation/stable/tutorial.html
    """

    def __init__(self, state_class=State_default):
        super(Graph, self).__init__()
        self._name_op_map = {}
        self._trainable_variables_collection = {}
        self.state_class = state_class

        # learning-related attributes
        self.reward = 0             # stores overall computed cumulative reward
        self.state = None           # stores current state
        self.last_state = None      # stores the last state, before the last_action and 
                                    #  before receiving last_reward
        self.last_action = None     # stores the last action
        self.last_reward = None     # stores the last action's reward
        self.learning_model = None  # stores the learning model, if applicable

    def get_name_op_map(self):
        return self._name_op_map

    def get_trainable_variables_collection(self):
        return self._trainable_variables_collection

    def add_to_trainable_variables_collection(self, key, value):
        if key in self._trainable_variables_collection:
            logging.warning(
                "The key: {} exists in trainable_variables_collection".format(key)
            )
        else:
            self._trainable_variables_collection[key] = value

    def get_unique_name(self, original_name):
        """Returns a unique name for the given original_name

        NOTE: applies only to Mul and Add operations, as they are the relevant ones
        which are repeated in the graph and don't count for the learning models
        """
        if "Mul" in original_name or \
            "Add" in original_name or \
            "State" in original_name:
            
            unique_name = original_name
            index = 0
            while unique_name in self._name_op_map.keys():
                index += 1
                base_name = unique_name.split("_")[0]
                unique_name = "{}_{}".format(base_name, index)
            return unique_name
        else:        
            return original_name  # do not change names, as it conflicts
                                  # with leaning models

    def add_to_graph(self, expl):
        unique_name = self.get_unique_name(expl.get_name())
        expl.set_name(unique_name)
        self._name_op_map[expl.get_name()] = expl
        self.add_node(expl)

    def add_reward_graph(self, reward):
        """Adds a reward to the graph"""
        self.reward += reward
        # return reward

    def updates_state(self, state):
        """Updates latest state in the graph"""
        self.state = state

    def update(self, expl, reward, state, auxiliary=False, debug=False):
        """Updates graph's state, after expl and obtaining reward
        
        Parameters
        ----------
        expl : Exploit
            corresponds with the action taken, the exploit
        reward : int
            numercial value representing the reward, positive or negative
        state : State
            resulting state after the exploit
        auxiliary : bool, optional
            whether the update is auxiliary or not, by default False. Used
            with no-op exploits, whose operation's results should not be added to the graph
            (e.g. MultipleExploit or StateExploit)
        debug : bool, optional
            whether to print debug messages or not, by default False
        """

        if not auxiliary:
            self.last_state = self.state
            self.last_reward = reward
            self.last_action = expl

            self.add_reward_graph(reward)
        self.updates_state(state)

        if debug:
            print("Graph.update()")
            print("\t action: ", expl)
            print("\t reward: ", reward)
            print("\t cum. reward: ", self.reward)
            print("\t state: ", state)
            print("\t auxiliary: ", auxiliary)



    def to_dot(self, dotfile_path) -> None:
        """Export graph to a dot file

        NOTE: simple ASCII art visualizations can be
        made with https://dot-to-ascii.ggerganov.com/
        """
        nx.nx_pydot.write_dot(self, dotfile_path)

    def ascii(self) -> str:
        """Export graph to an ASCII art string

        NOTE: uses https://github.com/ggerganov/dot-to-ascii
        """
        dot = nx.nx_pydot.to_pydot(self)
        return requests.get(
            "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php",
            params={
                "boxart": 1,  # 0 for not fancy
                "src": str(dot),
            },
        ).text

    def plot(self) -> None:
        import matplotlib.pyplot as plt
        from networkx.drawing.nx_pydot import graphviz_layout

        # node colors
        node_color = []
        for node in list(_default_graph.nodes):
            if type(node) is exploit.InitExploit:
                node_color.append("white")
            elif node.status:
                node_color.append("green")
            else:
                node_color.append("red")

        # labels
        labels = {}
        for node in list(_default_graph.nodes):
            if type(node) is exploit.ConstantExploit:
                labels[node] = str(node.name) + "|" + str(node._value)
            else:
                labels[node] = node.name

        # rest of drawing
        pos = graphviz_layout(self, prog="dot")  # top-down tree
        nx.draw(
            self,
            node_color=node_color,
            with_labels=True,
            labels=labels,
            pos=pos,
            # connectionstyle="arc3,rad=0.2",
        )

        # redraw (other than Ops) Exploits
        exploits = [
            node
            for node in list(_default_graph.nodes)
            if (type(node) is exploit.ConstantExploit)
            or (type(node) is exploit.BoolExploit)
        ]
        nx.draw_networkx_nodes(self, pos, nodelist=exploits, node_shape="^")

        # draw edge labels
        edge_labels = nx.get_edge_attributes(self, "label")
        nx.draw_networkx_edge_labels(self, pos, edge_labels, font_size=5)

        plt.show()


# TODO: Make global variable for all packages
# i.e., consider moving it to __init__.py
if "_default_graph" not in globals():
    _default_graph = None


def get_default_graph(state_class=State_default):
    global _default_graph
    if _default_graph is None:
        _default_graph = Graph(state_class)
    return _default_graph

def reset_default_graph(state_class=State_default):
    global _default_graph    
    _default_graph = Graph(state_class)
    return _default_graph
